#!/usr/bin/env node
import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const root = path.resolve(__dirname, '..');

const paths = {
  packageJson: path.join(root, 'package.json'),
  tauriConf: path.join(root, 'src-tauri', 'tauri.conf.json'),
  cargoToml: path.join(root, 'src-tauri', 'Cargo.toml'),
  appVersionTs: path.join(root, 'src', 'appVersion.ts'),
};

/**
 * SemVer helper: Major.Minor.Patch
 * - supports flags: --use-current, --major[=N], --minor[=N], --patch[=N], --set X.Y.Z
 */

function parseSemVer(version) {
  if (!version) return null;
  const ver = version.split('-')[0].trim();
  const match = /^(?:v)?(\d+)\.(\d+)\.(\d+)$/.exec(ver);
  if (!match) return null;
  return {
    major: parseInt(match[1], 10),
    minor: parseInt(match[2], 10),
    patch: parseInt(match[3], 10),
  };
}

function formatSemVer(major, minor, patch) {
  return `${major}.${minor}.${patch}`;
}

function getOverrideFromArgs() {
  const args = process.argv.slice(2);
  const simpleSemVerRe = /^(?:v)?\d+\.\d+\.\d+$/;
  if (args.length && simpleSemVerRe.test(args[0])) return args[0];
  for (let i = 0; i < args.length; i++) {
    const a = args[i];
    if (a.startsWith('--set=')) return args[i].split('=')[1];
    if (a === '--set' && i + 1 < args.length) return args[i + 1];
    if (a.startsWith('--major')) {
      const val = a.includes('=') ? a.split('=')[1] : args[i + 1];
      return { bump: 'major', value: val && !a.includes('=') ? undefined : Number(val) };
    }
    if (a.startsWith('--minor')) {
      const val = a.includes('=') ? a.split('=')[1] : args[i + 1];
      return { bump: 'minor', value: val && !a.includes('=') ? undefined : Number(val) };
    }
    if (a.startsWith('--patch')) {
      const val = a.includes('=') ? a.split('=')[1] : args[i + 1];
      return { bump: 'patch', value: val && !a.includes('=') ? undefined : Number(val) };
    }
  }
  return undefined;
}

async function readJson(p) {
  const raw = await fs.readFile(p, 'utf8');
  return JSON.parse(raw);
}

async function writeJson(p, data) {
  const content = JSON.stringify(data, null, 2) + '\n';
  await fs.writeFile(p, content, 'utf8');
}

async function updateCargoToml(filePath, version) {
  const raw = await fs.readFile(filePath, 'utf8');
  const updated = raw.replace(
    /(^\s*version\s*=\s*")([^"]+)("\s*$)/m,
    (_m, a, _b, c) => `${a}${version}${c}`
  );
  await fs.writeFile(filePath, updated, 'utf8');
}

async function main() {
  const pkg = await readJson(paths.packageJson);
  const current = pkg.version || '0.0.0';

  const args = process.argv.slice(2);
  const useCurrent = args.includes('--use-current');

  let next = current;

  if (!useCurrent) {
    const override = getOverrideFromArgs();
    if (typeof override === 'string') {
      // explicit set
      next = override;
    } else if (override && typeof override === 'object') {
      const cur = parseSemVer(current) || { major: 0, minor: 0, patch: 0 };
      const bump = override.bump;
      const val = override.value;
      if (bump === 'major') {
        if (Number.isInteger(val)) {
          next = formatSemVer(val, 0, 0);
        } else {
          next = formatSemVer(cur.major + 1, 0, 0);
        }
      } else if (bump === 'minor') {
        if (Number.isInteger(val)) {
          next = formatSemVer(cur.major, val, 0);
        } else {
          next = formatSemVer(cur.major, cur.minor + 1, 0);
        }
      } else if (bump === 'patch') {
        if (Number.isInteger(val)) {
          next = formatSemVer(cur.major, cur.minor, val);
        } else {
          next = formatSemVer(cur.major, cur.minor, cur.patch + 1);
        }
      }
    } else {
      // default: bump patch
      const cur = parseSemVer(current) || { major: 0, minor: 0, patch: 0 };
      next = formatSemVer(cur.major, cur.minor, cur.patch + 1);
    }
  }

  if (next !== current) {
    pkg.version = next;
    await writeJson(paths.packageJson, pkg);
  }

  const tauri = await readJson(paths.tauriConf);
  tauri.version = next;
  await writeJson(paths.tauriConf, tauri);

  await updateCargoToml(paths.cargoToml, next);

  const tsContent = `// AUTO-GENERATED by scripts/version.mjs\nexport const APP_VERSION = '${next}';\n`;
  await fs.writeFile(paths.appVersionTs, tsContent, 'utf8');

  console.log(`version set to ${next}`);
}

main().catch((err) => {
  console.error('version script failed:', err);
  process.exit(1);
});
