#!/usr/bin/env node
import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const root = path.resolve(__dirname, '..');

const paths = {
  packageJson: path.join(root, 'package.json'),
  tauriConf: path.join(root, 'src-tauri', 'tauri.conf.json'),
  cargoToml: path.join(root, 'src-tauri', 'Cargo.toml'),
  appVersionTs: path.join(root, 'src', 'appVersion.ts'),
};

/**
 * CalVer format: YYYY.MM.R
 * - YYYY: Full year
 * - MM: Month (1-12)
 * - R: Release number in that month
 */

function parseCalVer(version) {
  const match = /^(\d{4})\.(\d{1,2})(?:\.(\d+))?$/.exec(version);
  if (!match) return null;
  return {
    year: parseInt(match[1], 10),
    month: parseInt(match[2], 10),
    release: match[3] ? parseInt(match[3], 10) : 1,
  };
}

function formatCalVer(year, month, release) {
  // semver compatibility 
  return `${year}.${month}.${release}`;
}

function buildVersion(date = new Date(), currentVersion) {
  const year = date.getFullYear();
  const month = date.getMonth() + 1; // 1-12

  const current = parseCalVer(currentVersion);
  
  if (current && current.year === year && current.month === month) {
    return formatCalVer(year, month, current.release + 1);
  }
  
  return formatCalVer(year, month, 1);
}

function getReleaseOverride() {
  const envVal = process.env.CALVER_RELEASE;
  if (envVal !== undefined && envVal !== '') {
    const n = Number(envVal);
    if (Number.isInteger(n) && n >= 1) return n;
  }
  
  const args = process.argv.slice(2);
  for (let i = 0; i < args.length; i++) {
    const a = args[i];
    if (a === '--release' && i + 1 < args.length) {
      const n = Number(args[i + 1]);
      if (Number.isInteger(n) && n >= 1) return n;
      i++;
    } else if (a.startsWith('--release=')) {
      const val = a.split('=')[1];
      const n = Number(val);
      if (Number.isInteger(n) && n >= 1) return n;
    }
  }
  return undefined;
}

async function readJson(p) {
  const raw = await fs.readFile(p, 'utf8');
  return JSON.parse(raw);
}

async function writeJson(p, data) {
  const content = JSON.stringify(data, null, 2) + '\n';
  await fs.writeFile(p, content, 'utf8');
}

async function updateCargoToml(filePath, version) {
  const raw = await fs.readFile(filePath, 'utf8');
  const updated = raw.replace(
    /(^\s*version\s*=\s*")([^"]+)("\s*$)/m,
    (_m, a, _b, c) => `${a}${version}${c}`
  );
  await fs.writeFile(filePath, updated, 'utf8');
}

async function main() {
  const pkg = await readJson(paths.packageJson);
  const current = pkg.version || '';

  const args = process.argv.slice(2);
  const useCurrent = args.includes('--use-current') || process.env.CALVER_MODE === 'sync';

  let next = current;
  
  if (!useCurrent) {
    const releaseOverride = getReleaseOverride();
    
    if (releaseOverride !== undefined) {
      const date = new Date();
      next = formatCalVer(date.getFullYear(), date.getMonth() + 1, releaseOverride);
    } else {
      next = buildVersion(new Date(), current);
    }
  }

  if (next !== current) {
    pkg.version = next;
    await writeJson(paths.packageJson, pkg);
  }

  const tauri = await readJson(paths.tauriConf);
  tauri.version = next;
  await writeJson(paths.tauriConf, tauri);

  await updateCargoToml(paths.cargoToml, next);

  const tsContent = `// AUTO-GENERATED by scripts/version.mjs\nexport const APP_VERSION = '${next}';\n`;
  await fs.writeFile(paths.appVersionTs, tsContent, 'utf8');

  console.log(`version set to ${next}`);
}

main().catch((err) => {
  console.error('version script failed:', err);
  process.exit(1);
});
